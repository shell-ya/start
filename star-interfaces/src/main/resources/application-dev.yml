spring:
  application:
    name: star
  shardingsphere:
      datasource:
        #数据库分库名
        names: ds0,ds1
        ds0:
          #type为数据源，如果是Druid数据库连接池，可以去改
          type: com.zaxxer.hikari.HikariDataSource
          driver-class-name: com.mysql.cj.jdbc.Driver
          jdbc-url: jdbc:mysql://sh-cynosdbmysql-grp-ibkpxd68.sql.tencentcdb.com:23543/star?serverTimezone=GMT%2B8&characterEncoding=utf8
          username: root
          password: wqd1234.
        ds1:
          type: com.zaxxer.hikari.HikariDataSource
          driver-class-name: com.mysql.cj.jdbc.Driver
          jdbc-url: jdbc:mysql://sh-cynosdbmysql-grp-ibkpxd68.sql.tencentcdb.com:23543/star?serverTimezone=GMT%2B8&characterEncoding=utf8
          username: root
          password: wqd1234.
      # 分片规则
      sharding:
        tables:
          # 设置逻辑表为 star_nft_order
          star_nft_order:
            actual-data-nodes: ds$->{0..1}.star_nft_order_$->{0..9} # 真实数据节点
#            # 指定 t_order 表里面主键 order_id 生成策略 为 SNOWFLAKE（雪花算法）
#            key-generator:
#              column: order_id
#              type: SNOWFLAKE
            # 指定数据库分片策略，根据 order_id 进行分库，是偶数则添加到 ds0，是奇数则添加到 ds1
            database-strategy:
              inline:
                sharding-column: user_id
                algorithm-expression: ds$->{order_id % 2}
            # 指定数据表分片策略，根据 order_user_id 进行分表，是偶数则添加到 t_order_0，是奇数则添加到 t_order_1
            table-strategy:
              inline:
                sharding-column: user_id
                algorithm-expression: star_nft_order_$->{user_id%10}
#          t_order_item:
#            actual-data-nodes: ds$->{0..1}.t_order_item_$->{0..1}
#            key-generator:
#              column: order_item_id
#              type: SNOWFLAKE
#            database-strategy:
#              inline:
#                sharding-column: order_id
#                algorithm-expression: ds$->{order_id % 2}
#            table-strategy:
#              inline:
#                sharding-column: order_user_id
#                algorithm-expression: t_order_item_$->{order_user_id%2}
        # 设置绑定关系
        binding-tables: star_nft_order
        # 默认数据源，即未配置分表规则的表数据存储表
        default-data-source: ds0
      # 在日志中SQL语句
      props:
        sql:
          show: true
#  datasource:
#    username: root
#    password: wqd1234.
#    type: com.alibaba.druid.pool.DruidDataSource
#    url: jdbc:mysql://sh-cynosdbmysql-grp-ibkpxd68.sql.tencentcdb.com:23543/star?serverTimezone=GMT%2B8&characterEncoding=utf8
#    driver-class-name: com.mysql.jdbc.Driver
#    druid:
#      max-active: 20
#      initial-size: 5
#      min-idle: 5
#      max-wait: 60000
  redis:
    host: 124.221.181.84
    database: 0
    port: 16379
    jedis:
      pool:
        max-active: 100
        max-idle: 10
        max-wait: 100000
    timeout: 20000
    password: wqd123456.

server:
  port: 8089

logging:
  level:
    com.starnft.star: debug

wallet:
  file:
    path: generator/english

# 发送短信验证码开关
star:
  sms:
    enable: false

rocketmq:
  name-server: 47.99.42.39:9876
  producer:
    group: star-producer-group
    isOnOff: on
    sendMsgTimeout: 30000
    maxMessageSize: 4096
    retryTimesWhenSendFailed: 2
  consumer:
    listeners: # 配置某个消费分组，是否监听指定 Topic 。结构为 Map<消费者分组, <Topic, Boolean>> 。默认情况下，不配置表示监听。
      test-consumer-group:
        topic1: false # 关闭 test-consumer-group 对 topic1 的监听消费
#    isOnOff: on
#    group: star-consumer-group
#    consumeThreadMin: 20
#    consumeThreadMax: 64
#    consumeMessageBatchMaxSize: 1

# 验证码相关配置
captcha:
  prefix: captcha
  # 验证码过期时间，默认是2分钟,单位毫秒， 可以根据自身业务进行调整
  expire:
    default: 30000
    # 文字点选验证码 过期时间设置大一点
    WORD_IMAGE_CLICK: 60000
  # 使用加载系统自带的资源， 默认是true
  init-default-resource: true
  cache:
    # 缓存控制， 默认为false不开启
    enabled: true
    # 验证码会提前缓存一些生成好的验证数据， 默认是20
    cache-size: 20
    # 缓存拉取失败后等待时间 默认是 5秒钟
    wait-time: 5000
    # 缓存检查间隔 默认是2秒钟
    period: 2000
  secondary:
    # 二次验证， 默认false 不开启
    enabled: false
    # 二次验证过期时间， 默认 2分钟
    expire: 120000
    # 二次验证缓存key前缀，默认是 captcha:secondary
    keyPrefix: "captcha.secondary"